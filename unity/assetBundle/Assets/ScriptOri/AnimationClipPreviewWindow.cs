using System.Collections.Generic;using UnityEditor;using UnityEngine;namespace UGame{    public struct FrameData    {        public string target;        public string model;        public float time;        public int index;    }    public struct Fragment    {        public string target;        public float time;        public int startIndex;        public int endIndex;        public int linkIndex;        public int linkCount;    }    public class AnimationClipPreviewWindow : EditorWindow    {

        /// 动画        private Animation motion;        private AnimationClip clip;        private string xmlName;        private string sourceName;        private readonly List<FrameData> frames = new List<FrameData>();        private readonly List<Fragment> fragments = new List<Fragment>();        private int step = 1;        private int curIndex = 0;        private int targetIndex = 0;        private int targetFrame = 0;        [MenuItem("CustomWindow/AnimationClipPreviewWindow")]        static void Open()        {            EditorApplication.isPlaying = true;            var win = GetWindow<AnimationClipPreviewWindow>("动画预览工具");            win.Show();        }        private void OnGUI()        {            motion = (Animation)EditorGUILayout.ObjectField(new GUIContent("动画对象"), motion, typeof(Animation), true);            if (motion == null) return;            clip = motion.clip;            if (clip == null) return;            EditorGUILayout.ObjectField(new GUIContent("动画文件"), clip, typeof(AnimationClip), false);            EditorGUILayout.LabelField("时间长度: ", clip.length.ToString());            EditorGUILayout.LabelField("帧率: ", clip.frameRate.ToString());            EditorGUILayout.LabelField("帧长度: ", GetFrameCount(clip.length).ToString());            EditorGUILayout.LabelField("有效帧数量: ", frames.Count.ToString());            if (GUILayout.Button("分析动画"))            {                Analyze();                MoveTargetFragment(0);                sourceName = motion.name;                xmlName = string.Concat("robot_", sourceName);            }            if (fragments.Count <= 0) return;            GUILayout.BeginHorizontal();            xmlName = EditorGUILayout.TextField(new GUIContent("Xml文件名: "), xmlName);            sourceName = EditorGUILayout.TextField(new GUIContent("模型名称: "), sourceName);            GUILayout.EndHorizontal();            if (GUILayout.Button("生成Xml"))            {                AnimationClipXmlExporter.ExportXml(xmlName, sourceName, fragments);            }            if (GUILayout.Button("合并Xml"))            {                AnimationClipXmlExporter.MergeXml(xmlName, sourceName);            }            GUILayout.Space(30);            GUILayout.BeginHorizontal();            if (GUILayout.Button("跳转开始"))            {                MoveTargetFragment(0);            }            if (GUILayout.Button("跳转结束"))            {                MoveTargetFragment(fragments.Count);            }            GUILayout.EndHorizontal();            GUILayout.BeginHorizontal();            targetIndex = EditorGUILayout.IntField(new GUIContent("指定下标: "), targetIndex);            if (GUILayout.Button("跳转"))            {                MoveTargetFragment(targetIndex);            }            GUILayout.EndHorizontal();            GUILayout.BeginHorizontal();            targetFrame = EditorGUILayout.IntField(new GUIContent("指定帧数: "), targetFrame);            if (GUILayout.Button("跳转"))            {                var index = FindFragmentIndex(targetFrame);                MoveTargetFragment(index);            }            GUILayout.EndHorizontal();            var fragment = GetCurFragment();            EditorGUILayout.LabelField("操作对象", string.Format("{0}[{1}/{2}]", fragment.target, fragment.linkIndex, fragment.linkCount));            EditorGUILayout.LabelField("当前片段: ", string.Format("start:{0} end:{1}", fragment.startIndex, fragment.endIndex));            GUILayout.BeginHorizontal();            if (GUILayout.Button("上一片段"))            {                MovePreFragment(step);            }            if (GUILayout.Button("下一片段"))            {                MoveNextFragment(step);            }            GUILayout.EndHorizontal();            GUILayout.BeginHorizontal();            if (GUILayout.Button("播放"))            {                Play(motion);            }            if (GUILayout.Button("停止"))            {                Stop(motion);            }            GUILayout.EndHorizontal();        }        private int GetFrameCount(float time)        {            return Mathf.RoundToInt(time * clip.frameRate);        }        private void Analyze()        {            frames.Clear();            Dictionary<float, List<string>> frameTimeToModels = new Dictionary<float, List<string>>();            var bindings = AnimationUtility.GetCurveBindings(clip);            for (int i = 0; i < bindings.Length; i++)            {                var binding = bindings[i];                var targetName = binding.path;                if (string.IsNullOrEmpty(targetName)) continue;                var strs = targetName.Split('/');                targetName = strs[0];                var curve = AnimationUtility.GetEditorCurve(clip, binding);                var keys = MergeKeyframes(curve.keys);                for (int j = 0; j < keys.Count; j++)                {                    var key = keys[j];                    var time = key.time;                    List<string> models;                    var modelName = targetName.Split('_')[0];                    if (frameTimeToModels.TryGetValue(time, out models))                    {                        continue;                        //if (models.Contains(modelName)) continue;                    }                    else                    {                        models = new List<string>();                        frameTimeToModels[time] = models;                    }                    models.Add(modelName);                    var data = new FrameData                    {                        target = targetName,                        model = modelName,                        time = time,                        index = GetFrameCount(time)                    };                    frames.Add(data);                }            }            frames.Sort((a, b) => a.time.CompareTo(b.time));            SplitFragments();        }        private List<Keyframe> MergeKeyframes(Keyframe[] keys)        {            if (keys.Length <= 1) return new List<Keyframe>(keys);            List<Keyframe> list = new List<Keyframe>();            var refKey = keys[0];            for (int i = 1; i < keys.Length; i++)            {                var nextKey = keys[i];                if (Mathf.Abs(refKey.value - nextKey.value) <= 0.01f)                {                    refKey = nextKey;                    continue;                }                if (list.Count == 0)                {                    list.Add(refKey);                }                refKey = nextKey;                list.Add(nextKey);            }            return list;        }        private void SplitFragments()        {            fragments.Clear();            List<FrameData> list = new List<FrameData>();            string model = string.Empty;            for (int i = 0; i < frames.Count; i++)            {                var frame = frames[i];                if (model.Equals(frame.model))                {                    list.Add(frame);                }                else                {                    SplitFragments(list);                    list.Clear();                    model = frame.model;                    list.Add(frame);                }            }            SplitFragments(list);        }        private void SplitFragments(List<FrameData> list)        {            var count = list.Count;            for (int i = 0; i < count - 1; i++)            {                var start = list[i];                var end = list[i + 1];                var fragment = new Fragment();                fragment.target = start.target;                fragment.time = end.time;                fragment.startIndex = start.index;                fragment.endIndex = end.index;                fragment.linkIndex = i + 1;                fragment.linkCount = count - 1;                fragments.Add(fragment);            }        }        private Fragment GetCurFragment()        {            return fragments[curIndex];        }        private void MovePreFragment(int count)        {            if (curIndex <= 0) return;            curIndex -= count;            if (curIndex < 0) curIndex = 0;            SetTimeline(motion, fragments[curIndex].time);        }        private void MoveNextFragment(int count)        {            if (curIndex >= fragments.Count - 1) return;            curIndex += count;            if (curIndex > fragments.Count - 1) curIndex = fragments.Count - 1;            SetTimeline(motion, fragments[curIndex].time);        }        private void MoveTargetFragment(int index)        {            if (index < 0) index = 0;            if (index > fragments.Count - 1) index = fragments.Count - 1;            curIndex = index;            SetTimeline(motion, fragments[curIndex].time);        }        private int FindFragmentIndex(int frameIndex)        {            for (int i = fragments.Count - 1; i >= 0; i--)            {                var startIndex = fragments[i].startIndex;                var endIndex = fragments[i].endIndex;                if (frameIndex == startIndex || frameIndex == endIndex)                {                    return i;                }            }            return 0;        }        private static void SetTimeline(Animation animation, float time)        {            var clip = animation.clip;            if (clip == null) return;            var clipName = clip.name;            AnimationState state = animation[clipName];            if (state == null) return;            state.speed = 1f;            state.time = time;            animation.Play(clipName);            state.speed = 0;        }        private static void Play(Animation animation)        {            var clip = animation.clip;            if (clip == null) return;            var clipName = clip.name;            AnimationState state = animation[clipName];            if (state == null) return;            state.speed = 1f;            animation.Play(clipName);            state.speed = 1;        }        private static void Stop(Animation animation)        {            var clip = animation.clip;            if (clip == null) return;            var clipName = clip.name;            AnimationState state = animation[clipName];            if (state == null) return;            state.speed = 1f;            state.speed = 0;        }    }}